#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Provision an EC2 instance for use as an OpenEdX sandbox
"""
import argparse
import os
import sys
import time

from boto.ec2 import EC2Connection


def parse_arguments():
    parser = argparse.ArgumentParser(
        description=__doc__,
    )
    parser.add_argument(
        '-n',
        '--instance-name',
        required=True,
    )
    parser.add_argument(
        '-d',
        '--disk-size',
        default=16,
        help='the disk size in MB(?)'
    )
    parser.add_argument(
        '-t',
        '--terminate',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-T',
        '--tear-down',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-c',
        '--create',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-b',
        '--bootstrap',
        default=False,
        action='store_true',
        help='provision vpc too?',
    )
    parser.add_argument(
        '-l',
        '--list',
        default=True,
        action='store_true',
    )
    parser.add_argument(
        '-s',
        '--start',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-S',
        '--stop',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-a',
        '--ami',
        default='ami-b06717d0',
        help='(default=ami-b06717d0, base=ami-2b2f594b)',
    )
    parser.add_argument(
        '-p',
        '--playbook',
        default='/home/stvstnfrd/src/edx/configuration/playbooks/edx_sandbox.yml',
    )
    parser.add_argument(
        '-P',
        '--playbook-directory',
        default='/home/stvstnfrd/src/edx/configuration/playbooks/',
    )
    arguments = parser.parse_args()
    return arguments

def get_instance(arguments):
    connection_ec2 = EC2Connection()
    name = "sandbox-instance-{instance_name}".format(
        instance_name=arguments.instance_name,
    )
    instances = connection_ec2.get_only_instances(
        filters={
            'tag:Name': name,
            'tag:Deployment': 'sandbox',
            # 'tag:Cluster': 'sandbox',
        },
    )
    instances = [
        instance
        for instance in instances
        if instance.state != 'terminated'
    ]
    len_instances = len(instances)
    assert len(instances) <= 1
    if len_instances == 1:
        instance = instances[0]
    else:
        instance = None
    return instance


def create_instance(arguments):
    os.environ['ANSIBLE_CONFIG'] = arguments.playbook_directory + 'ansible.cfg'
    import ansible
    from ansible.inventory import Inventory
    from ansible.playbook import PlayBook
    stats = ansible.callbacks.AggregateStats()
    callbacks = ansible.callbacks.PlaybookCallbacks(
        verbose=ansible.utils.VERBOSITY,
    )
    runner_callbacks = ansible.callbacks.PlaybookRunnerCallbacks(
        stats,
        verbose=ansible.utils.VERBOSITY,
    )
    inventory = Inventory(host_list='/home/stvstnfrd/src/edx/configuration/stanford/ec2.py')
    extra_vars = {
        'name_tag': arguments.instance_name,
        'edx_platform_version': 'master',
        'edxapp_theme_version': 'master',
        'edxapp_theme_source_repo': 'https://github.com/Stanford-Online/lagunita-theme.git',
        'edx_platform_repo': "https://github.com/Stanford-Online/edx-platform.git",
        'keypair': 'deployment',
        'terminate_instance': True,
        'ami': 'ami-2b2f594b',
        'root_ebs_size': 16,
    }
    play = PlayBook(
        playbook=arguments.playbook,
        extra_vars=extra_vars,
        inventory=inventory,
        callbacks=callbacks,
        runner_callbacks=runner_callbacks,
        remote_user='ubuntu',
        stats=stats,
    )
    play.run()
    callbacks.on_stats(play.stats)


def list_instance(arguments):
    instance = get_instance(arguments)
    if not instance:
        print('No such instance!', arguments)
        return None
    print(instance.tags)
    name = instance.tags['Name']
    name = name.split('-')[-1]
    dns = name + '-sandbox.class.stanford.edu'
    print('name', name)
    print('id', instance.id)
    print('id', instance.state)
    print('tags', instance.tags)
    print('instance_type', instance.instance_type)
    print('private_ip_address', instance.private_ip_address)
    print('public_dns_name', instance.public_dns_name)
    print('dns', dns)
    return instance


def update_instance(action, state_complete, arguments, dry_run=False):
    instance = get_instance(arguments)
    actionable = getattr(instance, action)
    actionable(dry_run=dry_run)
    instance = get_instance(arguments)
    while instance.state != state_complete:
        sys.stdout.write('.')
        sys.stdout.flush()
        time.sleep(3)
        instance.update()
    sys.stdout.write('\n')
    sys.stdout.flush()
    return instance


def bootstrap_vpc(arguments):
    print('TODO: bootstrap vpc')


def tear_down_vpc(arguments):
    print('TODO: tear down vpc')


def main(arguments):
    if arguments.stop:
        update_instance('stop', 'stopped', arguments)
    if arguments.terminate:
        update_instance('terminate', 'terminated', arguments)
        if arguments.tear_down:
            tear_down_vpc(arguments)
    if arguments.create:
        if arguments.bootstrap:
            bootstrap_vpc(arguments)
        create_instance(arguments)
    if arguments.start:
        update_instance('start', 'running', arguments)
    if arguments.list:
        list_instance(arguments)


if __name__ == '__main__':
    arguments = parse_arguments()
    main(arguments)
